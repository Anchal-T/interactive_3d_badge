/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three'
import React, { useState, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { CuboidCollider, RigidBody } from '@react-three/rapier'
import { ThreeMFLoader } from 'three/examples/jsm/Addons.js'
import { useThree, useFrame } from '@react-three/fiber'

export const Model = ({ ref, ...props }) => {
    const { nodes, materials } = useGLTF('/model/keyCard.glb')
    const [dragged, setDragged] = useState(false)
    const draggedOffsetRef = useRef(new THREE.Vector3())

    const vec = useRef(new THREE.Vector3()).current
    const dir = useRef(new THREE.Vector3()).current
    const rot = new THREE.Vector3()
    const ang = new THREE.Vector3()
    

    const { camera } = useThree()

    const handlePointerDown = (event) => {
        event.stopPropagation()
        if (ref.current) {
            draggedOffsetRef.current.copy(event.point).sub(ref.current.translation())
            setDragged(true)

        }
    }
    const handlePointerUp = (event) => {
        event.stopPropagation();
        setDragged(false);
    };

    useFrame((state) => {
        if (dragged && ref.current) {
            vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(camera)
            dir.copy(vec).sub(camera.position).normalize()
            vec.add(dir.multiplyScalar(camera.position.length()))

            ref.current.wakeUp()
            ref.current.setNextKinematicTranslation({
                x: vec.x - draggedOffsetRef.current.x,
                y: vec.y - draggedOffsetRef.current.y,
                z: vec.z - draggedOffsetRef.current.z,
            });
        }

        // Add this rotation control part:
        if (ref.current) {
            ang.copy(ref.current.angvel())
            rot.copy(ref.current.rotation())
            ref.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z })
        }
    })

    return (
        <RigidBody
            ref={ref}
            {...props}
            type={dragged ? 'kinematicPosition' : 'dynamic'}>
            angularDamping={2}
            linearDamping={2}
            canSleep={true}
            colliders={false}
            <CuboidCollider args={[0.8, 1.025, 0.01]} />

            <group
                {...props}
                dispose={null}
                onPointerUp={handlePointerUp}
                onPointerDown={handlePointerDown}
            >
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Plane.geometry}
                    material={nodes.Plane.material}
                    position={[-0.002, 0.674, -0.03]}
                    rotation={[-0.158, 1.538, 1.684]}
                    scale={0.357}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.clamp.geometry}
                    material={materials.metal}
                    position={[0.001, 1.067, -0.038]}
                    rotation={[-0.086, -0.113, 0.1]}
                    scale={1.285}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.clip.geometry}
                    material={materials.metal}
                    position={[-0.01, 1.203, -0.049]}
                    rotation={[-0.206, 1.033, 0.211]}
                    scale={0.991}
                />
            </group>
        </RigidBody>
    )
}

useGLTF.preload('/model/keyCard.glb')
