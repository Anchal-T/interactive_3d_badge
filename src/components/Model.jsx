/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three'
import React, { useState, useRef, useEffect, useMemo } from 'react'
import { useGLTF, useTexture } from '@react-three/drei'
import { CuboidCollider, RigidBody } from '@react-three/rapier'
import { useThree, useFrame, extend } from '@react-three/fiber'
import { HolographicMaterial } from './HolographicMaterial'

export const Model = ({ ref, cardType = 'water', ...props }) => {
    const { nodes, materials } = useGLTF('/model/keyCard.glb')
    const [dragged, setDragged] = useState(false)
    const draggedOffsetRef = useRef(new THREE.Vector3())    // Pokemon card texture mappings
    const cardTextureMappings = useMemo(() => ({
        // Base repository URL for textures (raw GitHub content)
        baseUrl: 'https://raw.githubusercontent.com/simeydotme/pokemon-cards-css/main/public/img',
        
        // Using actual background images from the Pokemon Cards CSS repo
        cardBases: {
            water: '/cosmos.png',      // Cosmos holographic background
            // fire: '/galaxy.jpg',       // Galaxy holographic background  
            // grass: '/trainerbg.png',   // Trainer background pattern
            // lightning: '/cosmos.jpg',  // Cosmos background
            // psychic: '/galaxy.jpg',    // Galaxy background
            // fighting: '/trainerbg.png', // Trainer background
            // darkness: '/galaxy.jpg',   // Galaxy background (darker theme)
            // metal: '/cosmos.jpg',      // Cosmos background
            // colorless: '/grain.webp',  // Grain texture
            // dragon: '/cosmos.jpg'      // Cosmos background
        },
        
        // Additional textures for effects
        effects: {
            grain: '/grain.webp',      // Grain texture for subtle noise
            glitter: '/glitter.png',   // Glitter texture for sparkle effects
            cosmos: '/cosmos.png',     // Cosmos pattern
            galaxy: '/galaxy.jpg',     // Galaxy pattern
            trainerbg: '/trainerbg.png' // Trainer background
        }
    }), []);    // Generate texture URLs for holographic background and Pokemon card
    const textureUrls = useMemo(() => {
        const baseUrl = cardTextureMappings.baseUrl;
        const cardBase = cardTextureMappings.cardBases[cardType] || cardTextureMappings.cardBases.water;
        
        return {
            holographic: `${baseUrl}${cardBase}`,
            pokemonCard: '/textures/pikachu.png', // Local Pokemon card texture
            grain: `${baseUrl}${cardTextureMappings.effects.grain}`,
            glitter: `${baseUrl}${cardTextureMappings.effects.glitter}`,
            cosmos: `${baseUrl}${cardTextureMappings.effects.cosmos}`
        };
    }, [cardType, cardTextureMappings]);
    
    // Load both textures
    const textures = useTexture(textureUrls);

    const vec = useRef(new THREE.Vector3()).current
    const dir = useRef(new THREE.Vector3()).current
    const rot = new THREE.Vector3()
    const ang = new THREE.Vector3()
    
    const { camera } = useThree()

    const handlePointerDown = (event) => {
        event.stopPropagation()
        if (ref.current) {
            draggedOffsetRef.current.copy(event.point).sub(ref.current.translation())
            setDragged(true)
        }
    }
    
    const handlePointerUp = (event) => {
        event.stopPropagation();
        setDragged(false);
    };

    useFrame((state) => {
        if (dragged && ref.current) {
            vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(camera)
            dir.copy(vec).sub(camera.position).normalize()
            vec.add(dir.multiplyScalar(camera.position.length()))

            ref.current.wakeUp()
            ref.current.setNextKinematicTranslation({
                x: vec.x - draggedOffsetRef.current.x,
                y: vec.y - draggedOffsetRef.current.y,
                z: vec.z - draggedOffsetRef.current.z,
            });
        }

        // Add rotation control part:
        if (ref.current) {
            ang.copy(ref.current.angvel())
            rot.copy(ref.current.rotation())
            ref.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z })
        }
    })

    return (
        <RigidBody
            ref={ref}
            {...props}
            type={dragged ? 'kinematicPosition' : 'dynamic'}
            angularDamping={2}
            linearDamping={2}
            canSleep={true}
            colliders={false}
        >
            <CuboidCollider args={[0.8, 1.025, 0.01]} />
            <group
                {...props}
                dispose={null}
                onPointerUp={handlePointerUp}
                onPointerDown={handlePointerDown}
            >                {/* Main card face with holographic material */}
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Plane.geometry}
        position={[-0.002, 0.674, -0.011]}
        rotation={[-2.405, 1.566, -2.309]}
        scale={0.357}                >                    
                <HolographicMaterial 
                        cardTexture={textures.pokemonCard}
                        holoTexture={textures.holographic}
                        grainTexture={textures.grain}
                        noiseTexture={textures.glitter}
                        normalTexture={textures.cosmos}
                        type={cardType}
                    />
                </mesh>
                
                {/* Keep the metal parts as they were */}
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.clamp.geometry}
                    material={materials.metal}
                            position={[0.001, 1.067, -0.004]}
        rotation={[-0.003, -0.331, 0.006]}
        scale={1.285}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.clip.geometry}
                    material={materials.metal}
        position={[0.001, 1.203, -0.011]}
        rotation={[-0.018, -0.338, 0.003]}
        scale={0.991}                />
            </group>
        </RigidBody>
    )
}

useGLTF.preload('/model/keyCard.glb')
